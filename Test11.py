#!/usr/bin/python
# coding: utf-8
#
# Markov chain algorithm implementation
#
# 2011 (c) Francesco Gigli <jaramir@gmail.com>
#

import random

# print a new text similar to the one passed as argument
# incrementing size produces more sense-full but less various results
def markov( source, size=2 ):

    # transform source in a list of words
    words = []
    for i in range( size ):
        words.append( None )

    for word in source.split( " " ):
        # skip empty elements generated by double spaces
        if word:
            words.append( word )

    words.append( None )

    # build the states table
    states = {}

    for i in range( len( words ) - size ):
        prefix = tuple(words[i:(i+size)])
        suffix = words[i+size]

        if prefix not in states:
            states[prefix] = []

        states[prefix].append( suffix )

    # build the new text
    text = ""
    next = words[size]
    current = words[:size]

    while next:
        text += next

        if not next.endswith( "\n" ):
            text += " "

        current.pop( 0 )
        current.append( next )

        next = random.choice( states[tuple(current)] )

    return text

if __name__ == "__main__":
    import sys
    import time
    # if no argument is given uses this file as the source
    text = open( sys.argv[-1] ).read()
    start = time.time()
    generated = markov( text, 4 )
    stop = time.time()
    print generated
    print "generated in ", (stop - start), "seconds"
